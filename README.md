/**
 * 1、用 <Editor /> 包裹我们的应用，以设置编辑器的上下文。在 resolver 属性中指定用户组件的列表，以便 Craft.js 能够对我们的用户组件进行（反）序列化。
 * 2、然后用 <Frame /> 包裹可编辑区域，这样可以将渲染过程交给 Craft.js 处理。 在 <Frame /> 中渲染的每个元素都由编辑器内部状态中的一个称为 Node 的对象管理，该对象描述了元素、其事件和属性等信息。
 * 3、一个元素是否可拖动或可放置（或两者皆非）取决于管理它的 Node 类型：
    如果 Node 是 Canvas，则它是可放置的；

    如果 Node 是 Canvas 的直接子元素，则它是可拖动的。
 * 4、默认情况下，<Frame /> 内的每个元素都会自动定义一个非 Canvas 节点。因此，默认情况下，上述所有节点都既不可拖动也不可放置。
 * 5、可以使用提供的 <Element /> 组件来手动定义节点
 * 
 * 
 * 6、使用 useNode 钩子 Craft.js 管理我们组件的 DOM。这个钩子提供了连接器，充当 DOM 和 Craft.js 事件之间的桥梁。 还可以通过 craft 属性为我们的组件指定额外的配置
    connect：将 connect 连接器传递给组件的根元素，这告诉 Craft.js 该元素代表文本组件。如果该组件对应的节点是一个 Canvas，那么这也定义了可放置的区域。
    drag：将 drag 连接器传递给同一根元素，这为 DOM 添加了拖动处理程序。如果该组件的节点是 Canvas 的子节点，用户将能够拖动此元素，从而移动整个文本组件。
 * 
 * 7、<Element /> 在用户组件中使用时必须指定 id 属性
 * 8、每个用户组件必须添加到我们的解析器中
 * 
 * 9、工具箱组件
    connectors
      create ：将拖拽处理程序附加到其第一个参数指定的 DOM 上，并创建第二个参数指定的元素。
  
 * 10、 可编辑功能
      react-contenteditable 实现一个内容可编辑的功能 
      useNode 钩子提供了 setProp 方法，可以用来操作组件的属性。
      useNode 钩子接受一个收集器函数，可以用来检索与相应节点相关的状态信息。
 *
 * 11、useEditor：获取当前选择的组件，获取编辑器内部状态
 * 12、query 
   query.serialize()  获取序列化json
   将json传入 Frame 来回显
 */